package visitor;

import syntaxtree.*;

import errorMsg.*;
import java.io.*;

public class CG3Visitor extends ASTvisitor {


	// the purpose here is to annotate things with their offsets:
	// - formal parameters, with respect to the (callee) frame
	// - local variables, with respect to the frame
	// - instance variables, with respect to their slot in the object
	// - methods, with respect to their slot in the v-table
	// - while statements, with respect to the stack-size at the time
	//   of loop-exit
	
	// IO stream to which we will emit code
	CodeStream code;

	// current stack height
	int stackHeight;
	
	// error-message object
	ErrorMsg errorMsg;
	
	public CG3Visitor(ErrorMsg e, PrintStream out) {
		initInstanceVars(e, out);
	}
	
	private void initInstanceVars(ErrorMsg e, PrintStream out) {
		errorMsg = e;
		code = new CodeStream(out, errorMsg);
		stackHeight = 0;
	}
	
	public Object visitLocalVarDecl(LocalVarDecl n) {
		n.initExp.accept(this);
		n.offset = -stackHeight;
		
		return null;
	}
	
	@Override
	public Object visitStringLiteral(StringLiteral n) {
		code.emit(n, "subu $sp, $sp, 4");
		stackHeight += 4;
		code.emit(n, "la $t0, strLit_" + n.uniqueCgRep.uniqueId);
		code.emit(n, "sw $t0, ($sp)");
		
		return null;
	}
	
	@Override
	public Object visitIntegerLiteral(IntegerLiteral n) {
		code.emit(n, "subu $sp, $sp, 8");
		stackHeight += 8;
		code.emit(n, "sw $s5, 4($sp)");
		code.emit(n, "li $t0, " + n.val);
		code.emit(n, "sw $t0, ($sp)");
		
		return null;
	}
	
	@Override
	public Object visitPlus(Plus n) {
		n.left.accept(this);
		n.right.accept(this);
		
		code.emit(n, "lw $t0, ($sp)");
		code.emit(n, "lw $t1, 8($sp)");
		code.emit(n, "addu $t0, $t0, $t1");
		code.emit(n, "addu $sp, $sp, 8");
		stackHeight -= 8;
		code.emit(n, "sw $t0, ($sp)");
		return null;
	}
	
	@Override
	public Object visitMinus(Minus n){
		n.left.accept(this);
		n.right.accept(this);
		
		code.emit(n, "lw $t0, ($sp)");
		code.emit(n, "lw $t1, 8($sp)");
		code.emit(n, "subu $t0, $t1, $t0");
		code.emit(n, "addu $sp, $sp, 8");
		stackHeight -= 8;
		code.emit(n, "sw $t0, ($sp)");
		
		return null;
	}
	
	@Override
	public Object visitThis(This n) {
		code.emit(n, "subu $sp, $sp, 4");
		stackHeight += 4;
		code.emit(n, "sw $s2, ($sp)");
		
		return null;
	}
	
	@Override
	public Object visitSuper(Super n) {
		code.emit(n, "subu $sp, $sp, 4");
		stackHeight += 4;
		code.emit(n, "sw $s2, ($sp)");
		
		return null;
	}
	
	@Override
	public Object visitNewObject(NewObject n) {
		code.emit(n, "subu $sp, $sp, 4");
		stackHeight += 4;
		code.emit(n, "sw $zero, ($sp)");
		
		return null;
	}
	
	@Override
	public Object visitCall(Call n) {
		int currentStackHeight = stackHeight;
		n.obj.accept(this);
		n.parms.accept(this);
		
		//treat all method calls as if they were super
		if(n.methodLink.pos < 0) {
			code.emit(n, "jal " + n.methodLink.name);
		} else {
			code.emit(n, "jal fcn_" + n.methodLink.uniqueId + "_" + n.methodLink.name);
		}
		
		if ( n.type instanceof VoidType ) {
			stackHeight = currentStackHeight + 0;
		} 
		else if (n.type instanceof IntegerType) {
			stackHeight = currentStackHeight + 8;
		}
		else {
			// instance of StringType
			stackHeight = currentStackHeight + 4;
		}
		
		return null;
	}
	
	@Override
	public Object visitIdentifierExp(IdentifierExp n) {
		if ( n.link instanceof InstVarDecl ) {
			code.emit(n, "lw $t0, " + n.link.offset + "($s2)");
		}
		else {
			int stackDepth = stackHeight + n.link.offset;
			code.emit(n, "lw $t0, " + stackDepth + "($sp)");
		}
		
		if ( n.type instanceof IntegerType ) {
			code.emit(n, "subu $sp, $sp, 8");
			stackHeight += 8;
			code.emit(n, "sw $s5, 4($sp)");
			code.emit(n, "sw $t0, ($sp)");
		}
		else {
			// type is an object array or boolean
			code.emit(n, "subu $sp, $sp, 4");
			stackHeight += 4;
			code.emit(n, "sw $t0, ($sp)");
		}
		
		return null;
	}
	
	@Override
	public Object visitProgram(Program n) {
		// generate main label for assembler-program
		code.emit(n, ".text");
		code.emit(n, ".globl main");
		code.emit(n, "main:");
		
		code.emit(n, "# initialize registers, etc.");
		code.emit(n, "jal vm_init");
		
		stackHeight = 0;
		
		n.mainStatement.accept(this);
		
		code.emit(n, "# exit program");
		code.emit(n, "li $v0, 10");
		code.emit(n, "syscall");
		
		code.emit(n, "CLASS_String:");
		code.emit(n, "CLASS_Object:");
		
		n.classDecls.accept(this);
		
		code.flush();
		
		return null;
	}
	
	@Override
	public Object visitMethodDeclVoid(MethodDeclVoid n) {
		code.emit(n, ".globl fcn_" + n.uniqueId + "_" + n.name);
		code.emit(n, "fcn_" + n.uniqueId + "_" + n.name + ":");
		code.emit(n, "subu $sp, $sp, 8");
		code.emit(n, "sw $ra, 4($sp)");
		code.emit(n, "sw $s2, ($sp)");
		
		stackHeight = 4;
		
		int stacktopRelativePosition = 4 + n.thisPtrOffset;
		
		code.emit(n, "lw $s2, " + stacktopRelativePosition + "($sp)");
		
		n.stmts.accept(this);
		
		// determine the offset of the saved return address
		int offsetOfSavedReturnAddress = stackHeight;
		code.emit(n, "lw $ra, " + offsetOfSavedReturnAddress + "($sp)");
		
		// saved this-pointer address relative to the current stack height
		int thisPointer = stackHeight - 4;
		code.emit(n, "lw $s2, " + thisPointer + "($sp)");
		
		// Stack height plus space for return address and space for this-pointer
		int toPopOff = stackHeight + 8;
		
		code.emit(n, "addu $sp, $sp, " + toPopOff);
		code.emit(n, "jr $ra");
		
		return null;
		
	}
	
}